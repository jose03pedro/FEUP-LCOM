<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend IsCProject="true" IsPhysical="false" AppName="lcom2" Platform="DotNet" FileWrittenByProductVersion="2023.1.0.27">
  <OutputDir KeepXmlFiles="False">C:\Users\Miguel Dionísio\OneDrive\Documentos\LCOM\MINIX-LCOM\shared\g2\proj\src\CppDependOut</OutputDir>
  <Projects />
  <FrameworkProjects />
  <Dirs />
  <Excludes />
  <ZipSourceFiles>True</ZipSourceFiles>
  <Report Kind="0" SectionsEnabled="110591" XslPath="" Flags="261120" />
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <UMLFiles UMLSections="511" />
  <Plugins Plugin="true" Vera="false" Modernize="false" CLangArgs="-checks=*,-android-*,-boost-*,-google-*,-fuchsia-*,-mpi-*,-objc-*">
    <LoadedPlugins />
  </Plugins>
  <ProjectParserSettings ParseIncludes="false" ParserKind="clang" QmakeFilePath="" TIPath="" ReneseasPath="" ArmPath="" ParserNbCores="0" ParserNbErrors="100" ParserTimeOut="10" />
  <TrendMetrics UseCustomLog="False" LogRecurrence="1" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult PersistRecurrence="1" UseCustomDir="False" CustomDir="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" />
  <ProjectDebtSettings DebtSettingsStorage="0" SettingsFilePath="">
    <DebtSettings>
      <DebtFactor>1</DebtFactor>
      <AnnualInterestFactor>1</AnnualInterestFactor>
      <DebtDefault>0</DebtDefault>
      <AnnualInterestDefault>0</AnnualInterestDefault>
      <DebtStringFormat>$ManDay$</DebtStringFormat>
      <MoneyPerManHour>50</MoneyPerManHour>
      <Currency>USD</Currency>
      <CurrencyLocation>After</CurrencyLocation>
      <EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>18</EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>
      <NumberOfWorkDayPerYear>240</NumberOfWorkDayPerYear>
      <NumberOfWorkHourPerDay>8</NumberOfWorkHourPerDay>
      <A2B_RatingThreshold>5</A2B_RatingThreshold>
      <B2C_RatingThreshold>10</B2C_RatingThreshold>
      <C2D_RatingThreshold>20</C2D_RatingThreshold>
      <D2E_RatingThreshold>50</D2E_RatingThreshold>
      <Info2Minor_SeverityThreshold>1200000000</Info2Minor_SeverityThreshold>
      <Minor2Major_SeverityThreshold>12000000000</Minor2Major_SeverityThreshold>
      <Major2Critical_SeverityThreshold>72000000000</Major2Critical_SeverityThreshold>
      <Critical2Blocker_SeverityThreshold>360000000000</Critical2Blocker_SeverityThreshold>
    </DebtSettings>
  </ProjectDebtSettings>
  <Queries>
    <Group Name="Quality Gates" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quality Gates Evolution</Name>
from qg in QualityGates
let qgBaseline = qg.OlderVersion()
let relyOnDiff = qgBaseline == null
let evolution = relyOnDiff ? (TrendIcon?)null : 
                // When a quality gate relies on diff between now and baseline
                // it is not executed against the baseline
                qg.ValueDiff() == 0d ?
                TrendIcon.Constant :
                (qg.ValueDiff() > 0 ? 
                  ( qg.MoreIsBad ?  TrendIcon.RedUp: TrendIcon.GreenUp) :
                  (!qg.MoreIsBad ?  TrendIcon.RedDown: TrendIcon.GreenDown))
select new { qg, 
   Evolution      =  evolution,

   BaselineStatus =  relyOnDiff? (QualityGateStatus?) null : qgBaseline.Status,
   Status         =  qg.Status,

   BaselineValue  =  relyOnDiff? (null) : qgBaseline.ValueString,
   Value          =  qg.ValueString, 
}
 
// <Description>
// Show quality gates evolution between baseline and now.
//
// When a quality gate relies on diff between now and baseline (like *New Debt since Baseline*)
// it is not executed against the baseline and as a consequence its evolution is not available.
//
// Double-click a quality gate for editing.
// </Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Code Coverage" Unit="%" />
failif value < 70%
warnif value < 80%
codeBase.PercentageCoverage

//<Description>
// Code coverage is a measure used to describe the degree to which the source code of a program 
// is tested by a particular test suite. A program with high code coverage, measured as a percentage, 
// has had more of its source code executed during testing which suggests it has a lower chance of 
// containing undetected software bugs compared to a program with low code coverage.
//
// Code coverage is certainly the most important quality code metric. But coverage is not enough
// the team needs to ensure that results are checked at test-time. These checks can be done both 
// in test code, and in application code through assertions. The important part is that a test
// must fail explicitely when a check gets unvalidated during the test execution.
//
// This quality gate define a warn threshold (70%) and a fail threshold (80%). These are 
// indicative thresholds and in practice the more the better. To achieve high coverage and 
// low risk, make sure that new and refactored classes gets 100% covered by tests and that
// the application and test code contains as many checks/assertions as possible.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on New Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.WasAdded() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *New Code* is defined as methods added since the baseline.
//
// To achieve high code coverage it is essential that new code gets properly
// tested and covered by tests. It is advised that all non-UI new classes gets
// 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on Refactored Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.CodeWasChanged() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *Refactored Code* is defined as methods where *code was changed* since the baseline.
//
// Comment changes and formatting changes are not considerd as refactoring.
//
// To achieve high code coverage it is essential that refactored code gets properly
// tested and covered by tests. It is advised that when refactoring a class
// or a method, it is important to also write tests to make sure it gets 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Blocker Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity == Severity.Blocker
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Issues" Unit="issues" />
failif count > 10 issues
warnif count > 0 issues

from i in Issues
where i.Severity == Severity.Critical
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worst it must 
// be fixed during the next iterations. 
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Blocker / Critical / Major Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High) &&  
      // Count both the new issues and the issues that became at least Critical
      (i.WasAdded() || i.OlderVersion().Severity < Severity.High)
select new { i, i.Severity, i.Debt, i.AnnualInterest }


//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed 
// during the next iterations. 
//
// An issue with a severity level **High** should be fixed quickly, but can wait until 
// the next scheduled interval.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Rules Violated" Unit="rules" />
failif count > 0 rules
from r in Rules where r.IsCritical && r.IsViolated()
select new { r, issues = r.Issues() }

//<Description>
// The concept of critical rule is useful to pinpoint certain rules that 
// should not be violated.
//
// A rule can be made critical just by checking the *Critical button* in the
// rule edition control and then saving the rule.
//
// This quality gate fails if any critical rule gets any violations.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this quality gate count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Debt" Unit="%" />
failif value > 30%
warnif value > 20%
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// % Debt total is defined as a percentage on:
//
// • the estimated total effort to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt)
//
// Estimated total effort to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-dat to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//
// This quality gates fails if the estimated debt is more than 30%
// of the estimated effort to develop the code base, and warns if the 
// estimated debt is more than 20% of the estimated effort to develop 
// the code base
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Debt in man-days can only depend on the 
// project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate **Percentage Debt**.
//
// The Debt is defined as the sum of estimated effort to fix all issues.
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Debt since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()


//<Description>
// This Quality Gate fails if the estimated effort to fix new or worsened
// issues (what is called the *New Debt since Baseline*) is higher
// than 2 man-days.
//
// This Quality Gate warns if this estimated effort is positive.
//
// Debt documentation: http://www.ndepend.com/Doc_TechnicalDebt#Debt
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt Rating per Namespace" Unit="namespaces" />
failif count > 0 namespaces

from n in Application.Namespaces
where n.DebtRating() != null &&
      n.DebtRating().Value.EqualsAny(DebtRating.E, DebtRating.D)
select new { 
   n, 
   debtRating = n.DebtRating(),
   debtRatio = n.DebtRatio(),  // % of debt from which DebtRating is inferred
   devTimeInManDay = n.EffortToDevelop().ToDebt(), 
   debtInManDay = n.AllDebt(),
   issues = n.AllIssues() 
}

// <Description>
// Forbid namespaces with a poor Debt Rating equals to **E** or **D**.
//
// The **Debt Rating** for a code element is estimated by the value of the **Debt Ratio**
// and from the various rating thresholds defined in this project *Debt Settings*. 
//
// The **Debt Ratio** of a code element is a percentage of **Debt Amount** (in floating man-days) 
// compared to the **estimated effort to develop the code element** (also in floating man-days).
//
// The **estimated effort to develop the code element** is inferred from the code elements
// number of lines of code, and from the project *Debt Settings* parameters 
// *estimated number of man-days to develop 1000* **logical lines of code**.
//
// The **logical lines of code** corresponds to the number of debug breakpoints in a method
// and doesn't depend on code formatting nor comments.
//
// The Quality Gate can be modified to match assemblies, types or methods
// with a poor Debt Rating, instead of matching namespaces.
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Annual Interest" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.AnnualInterest).ToManDay()


//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Annual-Interest in man-days can only depend
// on the project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate 
// **New Annual Interest since Baseline**.
//
// The Annual-Interest is defined as the sum of estimated annual cost
// in man-days, to leave all issues unfixed.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.ndepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Annual Interest since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Quality Gate fails if the estimated annual cost to leave all issues
// unfixed, increased from more than 2 man-days since the baseline.
//
// This Quality Gate warns if this estimated annual cost is positive.
//
// This estimated annual cost is named the **Annual-Interest**.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.ndepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>

]]></Query>
    </Group>
    <Group Name="Code Smells" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Files too big - critical</Name>
warnif count > 0 from f in Files where 
   f.NbLinesOfCode > 3000
   orderby f.NbLinesOfCode descending
select new { 
f, 
f.NbLinesOfCode,
  Debt = (f.NbLinesOfCode.Linear(200, 1, 2000, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = f.NbLinesOfCode.Linear(
                          200,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                          2000, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

// Files where NbLinesOfCode > 2000 are extremely complex 
// and should be split in a smaller group of files. 
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where !t.IsEnumeration &&
         t.Fields.Count() > 40
        
  // Count instance fields and non-constant static fields
  let fields = t.Fields.Where(f =>
          !f.IsGeneratedByCompiler &&        
          !(f.IsStatic ) &&
           JustMyCode.Contains(f) )

  where fields.Count() > 40
 
  let methodsAssigningFields = fields.SelectMany(f => f.MethodsAssigningMe)

  orderby fields.Count() descending
select new { 
   t, 
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
methodsAssigningFields ,   

   Debt = fields.Count().Linear(15, 1, 200, 10).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = fields.Count().Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 40 fields. 
// Such type might be hard to understand and maintain.
//
// Notice that constant fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// More refactoring advices can be found in the default rule 
// **Types to Big**, *HowToFix* section.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 15 fields,
// to up to 10 hours for a type with 200 or more fields. 
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods too big, too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
    (m.NbLinesOfCode > 100 ||
   m.CyclomaticComplexity > 30)

  let complexityScore = m.NbLinesOfCode/2 + m.CyclomaticComplexity 

  orderby complexityScore descending,
          m.CyclomaticComplexity descending
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   complexityScore,

   Debt = complexityScore.Linear(30, 40,    400, 8*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity minor 
   // to interest for severity major
   AnnualInterest = complexityScore .Linear(30,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                            200, 2*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule matches methods where
// and (*NbLinesOfCode* > 100 
// or *CyclomaticComplexity* > 30
// Such method is typically hard to understand and maintain.
//
// Maybe you are facing the **God Method** phenomenon.
// A "God Method" is a method that does way too many processes in the system 
// and has grown beyond all logic to become *The Method That Does Everything*.
// When need for new processes increases suddenly some programmers realize: 
// why should I create a new method for each processe if I can only add an *if*.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies from 40 minutes to 8 hours, linearly from a weighted complexity score.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters >= 10
  orderby m.NbParameters descending
select new { 
   m, 
   m.NbParameters,

   Debt = m.NbParameters.Linear(7, 1,  40, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 7 parameters
   // to interest for severity Critical for 40 parameters
   AnnualInterest = m.NbParameters.Linear(7,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          40, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches methods with more than 10 parameters.
// Such method is painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a method with 7 parameters,
// up to 6 hours for a methods with 40 or more parameters.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 25
  orderby m.NbVariables descending
select new { 
   m, 
   m.NbVariables,

   Debt = m.NbVariables.Linear(15, 1,   80, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 15 variables
   // to interest for severity Critical for 80 variables
   AnnualInterest = m.NbVariables.Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                         80,  Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule matches methods with more than 25 variables.
//
// Methods where *NbVariables > 15* are hard to understand and maintain.
// Methods where *NbVariables > 25* are extremely complex and must be refactored. 
//
// See the definition of the *Nbvariables* metric here: 
// http://www.cppdepend.com/Metrics.aspx#Nbvariables
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 minutes for a method with 15 variables,
// up to 2 hours for a methods with 80 or more variables.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbOverloads >= 10 && 
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
let overloads = 
 m.IsConstructor ? m.ParentType.Constructors :
                   m.ParentType.Methods.Where(m1 => m1.SimpleName == m.SimpleName)
select new { 
   m, 
   overloads,
   Debt = 2.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}

//<Description>
// Method overloading is the ability to create multiple methods of the same name 
// with different implementations, and various set of parameters.
//
// This rule matches sets of methods with 6 overloads or more.
//
// Such method set might be a problem to maintain 
// and provokes coupling higher than necessary.
//
// See the definition of the *NbOverloads* metric here 
// http://www.cppdepend.com/Metrics.aspx#NbOverloads
//</Description>

//<HowToFix>
// Typically the *too many overloads* phenomenon appears when an algorithm
// takes a various set of in-parameters. Each overload is presented as 
// a facility to provide a various set of in-parameters.
// In such situation, the C# and VB.NET language feature named 
// *Named and Optional arguments* should be used.
//
// The *too many overloads* phenomenon can also be a consequence of the usage
// of the **visitor design pattern** http://en.wikipedia.org/wiki/Visitor_pattern 
// since a method named *Visit()* must be provided for each sub type.
// In such situation there is no need for fix.
//
// Sometime *too many overloads* phenomenon is not the symptom of a problem,
// for example when a *numeric to something conversion* method applies to 
// all numeric and nullable numeric types.
//
// The estimated Debt, which means the effort to fix such issue,
// is of 2 minutes per method overload.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Code Smells Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all files added should respect basic quality principles</Name>
warnif count > 0 from f in JustMyCode.Files where

// Only match files added since Baseline.

   f.WasAdded() &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
f.NbLinesOfCode > 3000 
select new { 
   f, 
   f.NbLinesOfCode, 

   // Constant Debt estimation, since for such type rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (f.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that don't satisfy all quality criterions.
//
// Files matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it has too many methods,
// it has too many fields,
// or is using too many types.
// Any of these criterions is often a symptom of a type with too many responsibilities.
//
// Notice that to count methods and fields, methods like constructors 
// or property and event accessors are not taken account.
// Notice that constants fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//</Description>

//<HowToFix>
// To refactor such file and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
//
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to increase the quality of these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// Only match methods added since Baseline.
// Uncomment this line to match also refactored methods since Baseline.
// (m.WasAdded() || m.CodeWasChanged()) &&
   m.WasAdded() &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 100 ||          // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
   m.CyclomaticComplexity > 30 ||   // http://www.cppdepend.com/Metrics.aspx#CC
   m.NbParameters > 10 ||            // http://www.cppdepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 25                // http://www.cppdepend.com/Metrics.aspx#NbVariables
    )
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   m.NbParameters, 
   m.NbVariables,
  

   // Constant Debt estimation, since for such method rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 5.ToMinutes().ToDebt(),

   // The Severity is higher for new methods than for refactored methods
   AnnualInterest= (m.WasAdded() ? 3 : 1) *
                   Severity.High.AnnualInterestThreshold()
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule can be easily modified to also match methods refactored since baseline,
// that don't satisfy all quality criterions.
//
// Methods matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// Issues of this rule have a constant 5 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
// 
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new methods since baseline, because the proper time 
// to increase the quality of these methods is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex</Name>
warnif count > 0 

let complexityScoreProc = new Func<IMethod, double>(m => 
    (m.CyclomaticComplexity ).Value)

from m in JustMyCode.Methods where
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
  m.OlderVersion().CyclomaticComplexity > 6 

let complexityScore = complexityScoreProc(m)
let oldComplexityScore = complexityScoreProc(m.OlderVersion())
where complexityScore > oldComplexityScore 

let complexityScoreDiff = complexityScoreProc(m) - complexityScoreProc(m.OlderVersion())
orderby complexityScoreDiff descending

select new { 
   m,
   oldComplexityScore ,
   complexityScore ,
   diff= complexityScoreDiff,

   Debt = complexityScoreDiff.Linear(1, 15,   50, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = complexityScoreDiff.Linear(1,     Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                               50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// The method complexity is measured through the code metric
// *Cyclomatic Complexity* defined here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// This rule warns when a method already complex
// (i.e with *Cyclomatic Complexity* higher than 6)
// become even more complex since the baseline.
//
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 15 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>

warnif count > 0 
from m in JustMyCode.Methods where


  // Filter just here for optimization
  m.NbLinesOfCode > 100 &&

  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() 

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 100 && m.NbLinesOfCode > oldLoc

let diff = m.NbLinesOfCode - oldLoc
where diff > 0
orderby diff descending 

select new { 
   m,
   oldLoc,
   newLoc = m.NbLinesOfCode,
   diff,

   Debt = diff.Linear(1, 10,   100, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = diff .Linear(1,      Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                 100, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns when a method already large
// (i.e with more than 15 lines of code)
// become even larger since the baseline.
//
// The method size is measured through the code metric
// *# Lines of Code* defined here:
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain, and might not need refactoring.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 to 20 minutes depending 
// on the number of lines of code added.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Coding Standards" Active="True" ShownInReport="False">
      <Group Name="Cert C" Active="True" ShownInReport="False">
        <Group Name="Preprocessor (PRE)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>PRE30-C: Do not create a universal character name through concatenation</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_ucn_escape_incomplete" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }

//<Description>
//The C Standard supports universal character names that may be used in identifiers, character constants, and string literals to designate characters that are not in the basic character set. The universal character name \Unnnnnnnn designates the character whose 8-digit short identifier (as specified by ISO/IEC 10646) is nnnnnnnn. Similarly, the universal character name \unnnn designates
//the character whose 4-digit short identifier is nnnn (and whose 8-digit short identifier is
//0000nnnn).
//The C Standard, 5.1.1.2, paragraph 4 [ISO/IEC 9899:2011], says
//If a character sequence that matches the syntax of a universal character name is produced by token concatenation (6.10.3.3), the behavior is undefined.
//In general, avoid universal character names in identifiers unless absolutely necessary
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>PRE31-C: Avoid side effects in arguments to unsafe macros</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="bugprone-macro-repeated-side-effects" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }

//<Description>
//An unsafe function-like macro is one whose expansion results in evaluating one of its parameters
//more than once or not at all. Never invoke an unsafe macro with arguments containing an assignment, increment, decrement, volatile access, input/output, or other expressions with side effects
//(including function calls, which may cause side effects).
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Declarations and Initialization" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>DCL30-C: Declare objects with appropriate storage durations</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="danglingLifetime" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }

//<Description>
//Every object has a storage duration that determines its lifetime: static, thread, automatic, or allocated.
//According to the C Standard, 6.2.4, paragraph 2 [ISO/IEC 9899:2011],
//The lifetime of an object is the portion of program execution during which storage is
//guaranteed to be reserved for it. An object exists, has a constant address, and retains its
//last-stored value throughout its lifetime. If an object is referred to outside of its lifetime,
//the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to reaches the end of its lifetime.
//Do not attempt to access an object outside of its lifetime. Attempting to do so is undefined behavior and can lead to an exploitable vulnerability. 
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>DCL31-C:Declare identifiers before using them</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="err_missing_type_specifier" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//The C11 Standard requires type specifiers and forbids implicit function declarations. The C90
//Standard allows implicit typing of variables and functions. Consequently, some existing legacy
//code uses implicit typing. Some C compilers still support legacy code by allowing implicit typing,
//but it should not be used for new code. Such an implementation may choose to assume an implicit
//declaration and continue translation to support existing programs that used this feature.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>DCL37-C:Do not declare or define a reserved identifier</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_pp_macro_is_reserved_id" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//The behavior of a program that declares or defines an identifier in a context in
//which it is reserved or that defines a reserved identifier as a macro name is undefined. 
//</Description>

    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>DCL41-C: Do not declare variables inside a switch statement before the first case label</Name>
warnif count > 0 
from issue in ImportedIssues where issue.Type=="Rule6-4-4"
select new { issue,issue.FilePath,Line=issue.BeginLine} 

//<Description>
//If a programmer declares variables, initializes them before the first case statement, and then tries
//to use them inside any of the case statements, those variables will have scope inside the switch
//block but will not be initialized and will consequently contain indeterminate values
//</Description>


    ]]></Query>
        </Group>
        <Group Name="Expressions(Exp)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP30-C: Do not depend on the order of evaluation for side effects</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unsequenced_mod_use" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Evaluation of an expression may produce side effects. At specific points during execution, known
//as sequence points, all side effects of previous evaluations are complete, and no side effects of
//subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP32-C: Do not access a volatile object through a nonvolatile reference</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" 
&& issue.Type=="err_typecheck_convert_incompatible_volatile"  select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Referencing a volatile object by using a non-volatile
//lvalue is undefined behavior. The C Standard, 6.7.3 [ISO/IEC 9899:2011], states
//If an attempt is made to refer to an object defined with a volatile-qualified type through
//use of an lvalue with non-volatile-qualified type, the behavior is undefined.
//</Description>

    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP33-C:Do not read uninitialized memory</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="uninitvar" || issue.Type=="uninitdata") select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Local, automatic variables assume unexpected values if they are read before they are initialized.
//The C Standard, 6.7.9, paragraph 10, specifies [ISO/IEC 9899:2011]
//If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.

//When local, automatic variables are stored on the program stack, for example, their values default
//to whichever values are currently stored in stack memory.
//Additionally, some dynamic memory allocation functions do not initialize the contents of the
//memory they allocate.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP34-C: Do not dereference null pointers</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer"  select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//</Description>
//Dereferencing a null pointer is undefined behavior.
//On many platforms, dereferencing a null pointer results in abnormal program termination, but this
//is not required by the standard.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP35-C: Do not modify objects with temporary lifetime</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" 
&& issue.Type=="err_typecheck_expression_not_modifiable_lvalue"  select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//The C11 Standard [ISO/IEC 9899:2011] introduced a new term: temporary lifetime. Modifying an
//object with temporary lifetime is undefined behavior. According to subclause 6.2.4, paragraph 8
//A non-lvalue expression with structure or union type, where the structure or union contains a member with array type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime. Its lifetime begins when the expression is evaluated and its initial value is the value
//of the expression. Its lifetime ends when the evaluation of the containing full expression
//or full declarator ends. Any attempt to modify an object with temporary lifetime results in
//undefined behavior.
//</Description>

    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP36-C: Do not cast pointers into more strictly aligned pointer types</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_cast_align" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced
//type. Different alignments are possible for different types of objects. If the type-checking system
//is overridden by an explicit cast or the pointer is converted to a void pointer (void *) and then to
//a different type, the alignment of an object may be changed.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP37-C: Call functions with the correct number and type of arguments</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="err_typecheck_call_too_many_args" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Do not call a function with the wrong number or type of arguments.
//The C Standard identifies five distinct situations in which undefined behavior (UB) may arise as a
//result of invoking a function using a declaration that is incompatible with its definition or by supplying incorrect types or numbers of arguments
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP39-C: Do not access a variable through a pointer of an incompatible type</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidPointerCast" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Modifying a variable through a pointer of an incompatible type (other than unsigned char) can
//lead to unpredictable results. Subclause 6.2.7 of the C Standard states that two types may be distinct yet compatible and addresses precisely when two distinct types are compatible
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP40-C: Do not modify constant objects</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="err_typecheck_convert_incompatible_const" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//The C Standard, 6.7.3, paragraph 6 [ISO/IEC 9899:2011], states
//If an attempt is made to modify an object defined with a const-qualified type through
//use of an lvalue with non-const-qualified type, the behavior is undefined.
//See also undefined behavior 64.
//There are existing compiler implementations that allow const-qualified objects to be modified
//without generating a warning message
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP44-C: Do not rely on side effects in operands to sizeof,_Alignof, or _Generic</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_side_effects_unevaluated_context" && issue.Description.Contains(("lambda")) select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Some operators do not evaluate their operands beyond the type information the operands provide.
//When using one of these operators, do not pass an operand that would otherwise yield a side effect since the side effect will not be generated.
//The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the
//parenthesized name of a type. In most cases, the operand is not evaluated. A possible exception
//is when the type of the operand is a variable length array type (VLA); then the expression is evaluated. When part of the operand of the sizeof operator is a VLA type and when changing the
//value of the VLA’s size expression would not affect the result of the operator, it is unspecified
//whether or not the size expression is evaluated. 
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP45-C:Do not perform assignments in selection statements</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_condition_is_assignment" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Do not use the assignment operator in the contexts listed in the following table because doing so
//typically indicates programmer error and can result in unexpected behavior.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>EXP46-C. Do not use a bitwise operator with a Boolean-like operand</Name>
warnif count > 0         
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_precedence_bitwise_rel" select 
new { issue,issue.FilePath,Line=issue.BeginLine}

//<Description>
//Mixing bitwise and relational operators in the same full expression can be a sign of a logic error
//in the expression where a logical operator is usually the intended operator. Do not use the bitwise
//AND (&), bitwise OR (|), or bitwise XOR (^) operators with an operand of type _Bool, or the result of a relational-expression or equality-expression. If the bitwise operator is intended, it should
//be indicated with use of a parenthesized expression
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Floating Point (FLP)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>FLP30-C:Do not use floating-point variables as loop counters</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-flp30-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Because floating-point numbers represent real numbers, it is often mistakenly assumed that they
//can represent any simple fraction exactly. Floating-point numbers are subject to representational
//limitations just as integers are, and binary floating-point numbers cannot represent all real numbers exactly, even if they can be represented in a small number of decimal digits.
//</Description> 
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>FLP34-C: Ensure that floating-point conversions are within range of the new type</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_impcast_float_integer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//If a floating-point value is to be converted to a floating-point value of a smaller range and precision or to an integer type, or if an integer type is to be converted to a floating-point type, the value
//must be representable in the destination type.
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Array (ARR)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ARR30-C. Do not form or use out-of-bounds pointers or array subscripts</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Addition or subtraction of a pointer
//into, or just beyond, an array object and an integer type produces
//a result that does not point into, or
//just beyond, the same array object.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ARR36-C: Do not subtract or compare two pointers that do not refer to the same array</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparePointers" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }

//<Description>
//When two pointers are subtracted, both must point to elements of the same array object or just one
//past the last element of the array object (C Standard, 6.5.6 [ISO/IEC 9899:2011]); the result is the
//difference of the subscripts of the two array elements. Otherwise, the operation is undefined behavior
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ARR39-C: Do not add or subtract a scaled integer to a pointer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_ptr_arith_exceeds_bounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Pointer arithmetic is appropriate only when the pointer argument refers to an array, including an
//array of bytes. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object.) When performing pointer arithmetic, the size of the value to add to or subtract from a
//pointer is automatically scaled to the size of the type of the referenced array object. Adding or
//subtracting a scaled integer value to or from a pointer is invalid because it may yield a pointer that
//does not point to an element within or one past the end of the array. 
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Characters and Strings (STR)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>STR30-C: Do not attempt to modify string literals</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringLiteralWrite" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//At compile time, string literals are used to create an array of static storage duration of sufficient
//length to contain the character sequence and a terminating null character. String literals are usually referred to by a pointer to (or array of) characters. Ideally, they should be assigned only to
//pointers to (or arrays of) const char or const wchar_t. It is unspecified whether these arrays
//of string literals are distinct from each other. The behavior is undefined if a program attempts to
//modify any portion of a string literal. Modifying a string literal frequently results in an access violation because string literals are typically stored in read-only memory. (
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>STR34-C: Cast characters to unsigned char before converting to larger integer sizes</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="bugprone-signed-char-misuse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Signed character data must be converted to unsigned char before being assigned or converted
//to a larger signed type. This rule applies to both signed char and (plain) char characters on
//implementations where char is defined to have the same range, representation, and behaviors as
//signed char.
//However, this rule is applicable only in cases where the character data may contain values that
//can be interpreted as negative numbers. For example, if the char type is represented by a two’s
//complement 8-bit value, any character value greater than +127 is interpreted as a negative value
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Memory Management (MEM)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>MEM30-C:Do not access freed memory</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Evaluating a pointer—including dereferencing the pointer, using it as an operand of an arithmetic
//operation, type casting it, and using it as the right-hand side of an assignment—into memory that
//has been deallocated by a memory management function is undefined behavior. Pointers to
//memory that has been deallocated are called dangling pointers. Accessing a dangling pointer can
//result in exploitable vulnerabilities.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>MEM31-C. Free dynamically allocated memory when no longer needed</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_mismatched_delete_new" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Before the lifetime of the last pointer that stores the return value of a call to a standard memory
//allocation function has ended, it must be matched by a call to free() with that pointer value
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Input/Output (FIO)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>FIO38-C. Do not copy a FILE object</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-fio38-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//According to the C Standard, 7.21.3, paragraph 6 [ISO/IEC 9899:2011],
//The address of the FILE object used to control a stream may be significant; a copy of a
//FILE object need not serve in place of the original.
//Consequently, do not copy a FILE object.
//</Description>    
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>FIO42-C: Close files when they are no longer needed</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//A call to the fopen() or freopen() function must be matched with a call to fclose() before
//the lifetime of the last pointer that stores the return value of the call has ended or before normal
//program termination, whichever occurs first.
//In general, this rule should also be applied to other functions with open and close resources, such
//as the POSIX open() and close() functions, or the Microsoft Windows CreateFile() and
//CloseHandle() functions.
//</Description> 
    ]]></Query>
        </Group>
        <Group Name="Environment (ENV)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ENV33-C: Do not call system()</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//The C Standard system() function executes a specified command by invoking an implementation-defined command processor, such as a UNIX shell or CMD.EXE in Microsoft Windows. The
//POSIX popen() and Windows _popen() functions also invoke a command processor but create a
//pipe between the calling program and the executed command, returning a pointer to a stream that
//can be used to either read from or write to the pipe [IEEE Std 1003.1:2013].
//Use of the system() function can result in exploitable vulnerabilities, in the worst case allowing
//execution of arbitrary system commands. 
//</Description> 
    ]]></Query>
        </Group>
        <Group Name="Signals (SIG)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>SIG30-C: Call only asynchronous-safe functions within signal handlers</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="bugprone-signal-handler" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Call only asynchronous-safe functions within signal handlers. For strictly conforming programs,
//only the C standard library functions abort(), _Exit(), quick_exit(), and signal() can be
//safely called from within a signal handler.
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Error Handling (ERR)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>ERR34-C. Detect errors when converting a string to a number</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-err34-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//The cnd_wait() and cnd_timedwait() functions temporarily cede possession of a mutex so
//that other threads that may be requesting the mutex can proceed. These functions must always be
//called from code that is protected by locking a mutex. The waiting thread resumes execution only
//after it has been notified, generally as the result of the invocation of the cnd_signal() or
//cnd_broadcast() function invoked by another thread. The cnd_wait() function must be invoked from a loop that checks whether a condition predicate holds. A condition predicate is an expression constructed from the variables of a function that must be true for a thread to be allowed
//to continue execution. The thread pauses execution, via cnd_wait(), cnd_timedwait(), or
//some other mechanism, and is resumed later, presumably when the condition predicate is true and
//the thread is notified.
//</Description>
    ]]></Query>
        </Group>
        <Group Name="Concurrency (CON)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>CON36-C. Wrap functions that can spuriously wake up in a loop</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="bugprone-spuriously-wake-up-functions" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
        
    ]]></Query>
        </Group>
        <Group Name="Miscellaneous (MSC)" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>MSC30-C. Do not use the rand() function for generating pseudorandom numbers</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-msc30-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
//<Description>
//Pseudorandom number generators use mathematical algorithms to produce a sequence of numbers
//with good statistical properties, but the numbers produced are not genuinely random.
//The C Standard rand() function makes no guarantees as to the quality of the random sequence
//produced. The numbers generated by some implementations of rand() have a comparatively
//short cycle and the numbers can be predictable. Applications that have strong pseudorandom
//number requirements must use a generator that is known to be sufficient for their needs.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>MSC32-C. Properly seed pseudorandom number generators</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-msc32-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }

//<Description>
//A pseudorandom number generator (PRNG) is a deterministic algorithm capable of generating sequences of numbers that approximate the properties of random numbers. Each sequence is completely determined by the initial state of the PRNG and the algorithm for changing the state. Most
//PRNGs make it possible to set the initial state, also called the seed state. Setting the initial state is
//called seeding the PRNG.
//Calling a PRNG in the same initial state, either without seeding it explicitly or by seeding it with
//the same value, results in generating the same sequence of random numbers in different runs of
//the program. Consider a PRNG function that is seeded with some initial seed value and is consecutively called to produce a sequence of random numbers, S. If the PRNG is subsequently seeded
//with the same initial seed value, then it will generate the same sequence S.
//</Description>
    ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>POS44-C. Do not use signals to terminate threads</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" && issue.Type=="cert-pos44-c" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
    ]]></Query>
        </Group>
      </Group>
      <Group Name="CWE Coding Standard" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="bufferAccessOutOfBounds" || issue.Type=="possibleBufferAccessOutOfBounds"
 || issue.Type=="insecureCmdLineArgs"|| issue.Type=="invalidscanf") select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Divide By Zero</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unchecked Error Condition</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Declaration of Catch for Generic Exception</Name>
warnif count > 0 
from m in Methods where !m.IsEntryPoint
&& m.IsUsing("Keywords.generic_catch".AllowNoMatch()) select m  
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Improper Release of Memory Before Removing Last Reference ('Memory Leak')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="memleak" || issue.Type=="memleakOnRealloc"
 || issue.Type=="publicAllocationError"|| issue.Type=="leakNoVarFunctionCall") select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
  // <Name>Double Free</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Uninitialized Variable</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uninitvar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    } 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Incomplete Cleanup</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NULL Pointer Dereferenced</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
  // <Name>Use of Obsolete Functions</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_deprecated"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
  // <Name>Comparing instead of Assigning</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_unused_comparison"  select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
  // <Name>Omitted Break Statement in Switch</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unannotated_fallthrough" select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[
  // <Name>Dead Code</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unreachable" select 
new { issue,issue.FilePath,Line=issue.BeginLine,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.Critical} 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assignment to Variable without Use ('Unused Variable')</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreadVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always False</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always false")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    } 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always True</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always true")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }  
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Function Call with Incorrectly Specified Arguments</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="preprocessorErrorDirective"  && issue.Description.Contains("Wrong number")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Critical
    }  
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Potentially Dangerous Function</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="dangerousUsageStrtol" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Critical
    } 
  ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Operator Precedence Logic Error</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="clarifyCalculation" || issue.Type=="clarifyCondition")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Critical
    }
 
  ]]></Query>
      </Group>
    </Group>
    <Group Name="CWE Rules" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="bufferAccessOutOfBounds" || issue.Type=="possibleBufferAccessOutOfBounds"
 || issue.Type=="insecureCmdLineArgs"|| issue.Type=="invalidscanf") select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Divide By Zero</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unchecked Error Condition</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodiv"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unexpected Status Code or Return Value</Name>
warnif count > 0 
from issue in ImportedIssues where  issue.Type=="emptycatch"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Declaration of Throws for Generic Exception</Name>
warnif count > 0 
from issue in ImportedIssues where  issue.Type=="genericexception"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Improper Release of Memory Before Removing Last Reference ('Memory Leak')</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="memleak" || issue.Type=="memleakOnRealloc"
 || issue.Type=="publicAllocationError"|| issue.Type=="leakNoVarFunctionCall") select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Double Free</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Uninitialized Variable</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uninitvar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Incomplete Cleanup</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NULL Pointer Dereferenced</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Obsolete Functions</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_deprecated"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Missing Default Case in Switch Statement</Name>
warnif count > 0 
from issue in ImportedIssues where issue.Type=="Rule6-4-6"
select issue ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assigning instead of Comparing</Name>
warnif count > 0 
from issue in ImportedIssues where issue.Type=="Rule6-2-1"
select issue ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Comparing instead of Assigning</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="CLang" && issue.Type=="warn_unused_comparison"  select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Omitted Break Statement in Switch</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unannotated_fallthrough" select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Leftover Debug Code</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Dead Code</Name>
warnif count > 0 
from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_unreachable" select 
new { issue,issue.FilePath,Line=issue.BeginLine} ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Assignment to Variable without Use ('Unused Variable')</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreadVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always False</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always false")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Expression is Always True</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="knownConditionTrueFalse"  && issue.Description.Contains("always true")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }  ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Function Call with Incorrectly Specified Arguments</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="preprocessorErrorDirective"  && issue.Description.Contains("Wrong number")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }  ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use of Potentially Dangerous Function</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="dangerousUsageStrtol" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Operator Precedence Logic Error</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && (issue.Type=="clarifyCalculation" || issue.Type=="clarifyCondition")
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
 ]]></Query>
    </Group>
    <Group Name="Memory Management" Active="True" ShownInReport="False">
      <Group Name="Leaks" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning/dereferencing p after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocret" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory pointed to by varname is freed twice.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="doubleFree" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Allocation with funcName, funcName doesnt release it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakNoVarFunctionCall" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Return value of allocation function funcName is not stored.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakReturnValNotUsed" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible leak in public function. The pointer varname is not deallocated before it is allocated.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="publicAllocationError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class class is unsafe, class::varname can leak by wrong usage.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsafeClassCanLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Resource leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocating a deallocated pointer: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dereferencing varname after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocuse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The allocated size sz is not a multiple of the underlying types size.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Mismatching allocation and deallocation: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchAllocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Common realloc mistake: varname nulled but not freed upon failure</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleakOnRealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="Null Pointer" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Null pointer dereference</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible null pointer dereference if the default parameter value is used: pointer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerDefaultArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is possible null pointer dereference: pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerRedundantCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Auto Variables" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of local auto-variable assigned to a function parameter.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autoVariables" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of an auto-variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfAutoVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Pointer to local array variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnLocalVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to auto variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to temporary returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnTempReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocation of an auto-variable results in undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autovarInvalidDeallocation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of function parameter parameter returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfFunctionParameter" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentPtrArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Bounds Checking" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array array[2] index array[1][1] out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer is accessed out of bounds: buffer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="bufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strncatUsage" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>index is out of bounds: Supplied size 2 is larger than actual size 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="outOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The size argument is given as a char constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sizeArgumentAsChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index -1 is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer overrun possible for long command line arguments.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="insecureCmdLineArgs" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behaviour, pointer arithmetic  is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index index is used before limits check.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexThenCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination).</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="possibleBufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The array array is too small, the function function expects a bigger one.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="argumentSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory allocation size is negative.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeMemoryAllocationSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Declaration of array  with negative size is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeArraySize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array x[10] accessed at index 20, which is out of bounds. Otherwise condition y==20 is redundant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBoundsCond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="Primitive Types Usage" Active="True" ShownInReport="False">
      <Group Name="Boolean" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to floating point variable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a function returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfFuncReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two functions returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfTwoFuncsReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a variable having boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfBoolWithBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Incrementing a variable of type bool with postfix operator++ is deprecated by the C++ Standard. You should assign it the value true instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incrementboolean" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a boolean expression with an integer other than 0 or 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="compareBoolExpressionWithInt" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerArithBool" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="String" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Modifying string literal directly or indirectly is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringLiteralWrite" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behavior: Variable varname is used as parameter and destination in s[n]printf().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sprintfOverlappingData" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unusual pointer arithmetic. A value of type char is added to a string literal.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strPlusChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal Hello World doesnt match length argument for substr().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal compared with variable foo. Did you intend to use strcmp() instead?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="literalWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Char literal compared with pointer foo. Did you intend to dereference it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charLiteralWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Conversion of string literal Hello World to bool always evaluates to true.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringBooleanError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary comparison of static strings.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="staticStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of identical string variables.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Type" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting 32-bit value by 64 bits is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftTooManyBits" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed integer overflow for expression .</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="integerOverflow" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious code: sign conversion of var in calculation, even though var can have a negative value</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signConversion" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="Misc" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is division by zero at line 0.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodivcond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Instance of varname object is destroyed immediately.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedScopedObject" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Casting between float* and double* which have an incompatible binary data representation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidPointerCast" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting a negative value is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftNegative" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer varname must have size of 2 integers if used as parameter of pipe().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="wrongPipeParameterSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="raceAfterInterlockedDecrement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopy" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two identical variables with isless(varName,varName) always evaluates to false.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonFunctionIsAlwaysTrueOrFalse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Storing func_name() return value in char variable and then comparing with EOF.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="checkCastIntToCharAndBack" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Function parameter parametername should be passed by reference.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="passedByValue" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant code: Found a statement that begins with type constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="constStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signedCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownSignCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When using char variables in bit operations, sign extension can generate unexpected results.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charBitOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The scope of the variable varname can be reduced.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="variableScope" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopyInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant assignment of varname to itself.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="selfAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>memset() called to fill 0 bytes.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetZeroBytes" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname is a float, its representation is implementation defined.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname doesnt fit into an unsigned char.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetValueOutOfRange" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Clarify calculation precedence for + and ?.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyCalculation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ineffective statement similar to *A++;. Did you intend to write (*A)++;?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression on both sides of &&.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression in both branches of ternary operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpressionTernary" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Consecutive return, break, continue, goto or throw statements are unnecessary.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateBreak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Statements following return, break, continue, goto or throw will never be executed.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreachableCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Checking if unsigned variable varname is less than zero.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unsigned variable varname cant be negative so it is unnecessary to test it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is not.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="varFuncNullUB" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using NaN/Inf in a computation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nanInArithmeticExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comma is used in return statement. The comma can easily be misread as a ;.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="commaSeparatedReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant pointer operation on varname - its already a pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantPointerOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used. Should this be a case of the enclosing switch()?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabelSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabel" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Expression x = x++; depends on order of evaluation of side effects</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownEvaluationOrder" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Prefer prefix ++/-- operators for non-primitive types.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="postfixOperator" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode ,
             delta = (int) a.NbLinesOfCode - a.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New files</Name>
from f in Application.Files where 
 !f.ParentProject.WasAdded() &&
  f.WasAdded()
select new { f, f.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Files removed</Name>
from f in codeBase.OlderVersion().Application.Files where 
 !f.ParentProject.WasRemoved() &&
  f.WasRemoved()
select new { f, f.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Files where code was changed</Name>
from f in Application.Files where f.CodeWasChanged()
select new { f, f.NbLinesOfCode, 
             oldNbLinesOfCode = f.OlderVersion().NbLinesOfCode ,
             delta = (int) f.NbLinesOfCode - f.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select f]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select f
]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 (from t in Types where 
 !t.NameLike (@"^[A-Z]")      // The name of a type should begin with an Upper letter.
  && // Except if it is generated by compiler or ...
 !t.IsThirdParty && !t.IsGlobal
select new { t, t.NbLinesOfCode }).Take(10)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler && !t.IsThirdParty

where t.SimpleName.Length > 35 
select new { t, t.SimpleName }

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
 !m.IsGeneratedByCompiler 
  && m.SimpleName.Length > 35 && !m.IsThirdParty

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35 && !f.IsThirdParty
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
    </Group>
    <Group Name="Code Coverage" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>C.R.A.P method code metric</Name>

warnif count > 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { m, CRAP, CC, uncoveredPercentage = uncov*100, m.NbLinesOfCode }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without introducing any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that this rule doesn't match too short method
// with less than 10 lines of code.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
// and also write unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Complex methods partially covered by tests should be 100% covered</Name>

warnif count > 0 from m in JustMyCode.Methods 
 where 
    
     (  m.NbLinesOfCode > 30 || 
        m.CyclomaticComplexity > 30 || 
        m.NestingDepth > 4 || 
        m.NbVariables > 8) && 

     // Take care only of complex methods 
     // already partially covered, but not completely covered.
     m.PercentageCoverage > 0 &&
     m.PercentageCoverage < 100

  orderby m.NbLinesOfCodeNotCovered ascending,
          m.NbLinesOfCode descending
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeCovered, m.NbLinesOfCodeNotCovered, 
             m.CyclomaticComplexity, m.NestingDepth, m.NbVariables }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// There are default rules that warn about complex methods to refactor.
// The present rule warns about complex methods that are already a bit covered by tests
// but not 100% covered by tests.
//
// Such situation cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without creating any regression bug.
//
// Because the complex method is already covered partially by tests,
// it might be not so costly to write more tests to full cover it.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both:
//
// • refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
//
// • and also write more unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed poorly covered</Name>
warnif count > 0
from m in Application.Methods where 
  m.PercentageCoverage < 30 && 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets refactored,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes refactored.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added poorly covered</Name>
warnif count > 0
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 && 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets added,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes added.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 95% to 99% covered</Name>
warnif count > 0
from t in Application.Types where 
  t.PercentageCoverage >= 95 && 
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { t, t.PercentageCoverage, t.NbLinesOfCode, 
             t.NbLinesOfCodeNotCovered, methodsCulprit } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 95% to 99% covered</Name>
warnif count > 0
from n in Application.Namespaces where 
  n.PercentageCoverage >= 95 && 
  n.PercentageCoverage <= 99 

  let methodsCulprit = n.ChildMethods.Where(m => m.PercentageCoverage < 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { n, n.PercentageCoverage, n.NbLinesOfCode, 
             n.NbLinesOfCodeNotCovered, methodsCulprit  } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of 
// one or several classes in a namespace
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet in the namespace.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types not covered at all</Name>
from t in Application.Types where 
  t.PercentageCoverage == 0
  orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode }

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists types not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces not covered at all</Name>
from n in Application.Namespaces where 
  n.PercentageCoverage == 0
  orderby n.NbLinesOfCode descending
select new { n, n.NbLinesOfCode} 

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists namespaces not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)
from m in testMethods 
select m

//<Description>
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to enforce the quality of test code, you'll need to 
// consider test assemblies in your list of application assemblies 
// analyzed by NDepend.
//
// In such situation, this code query lists tests methods and you can 
// reuse this code in custom rules.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly called by test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr).ToHashSetEx()

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//let testAssemblies = testMethods.ParentAssemblies().ToHashSetEx()

from m in Application.Methods.UsedByAny(testMethods)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//where !testAssemblies.Contains(m.ParentAssembly)

select new { m , 
             calledByTests = m.MethodsCallingMe.Intersect(testMethods ),
             // --- Uncomment this line if your project import some coverage data ---
             // m.PercentageCoverage 
}


//<Description>
// This query lists all methods directly called by tests methods.
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly and indirectly called by test Methods</Name>

let testAttr = from t in ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute") select t
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
// let testAssemblies = testMethods.ParentAssemblies().ToHashSetEx()

let depthOfCalledByTest = Application.Methods.DepthOfIsUsedByAny(testMethods)
from pair in depthOfCalledByTest
where pair.Value > 0 
orderby pair.Value ascending
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//&& !testAssemblies.Contains(pair.CodeElement.ParentAssembly)

select new { 
  method = pair.CodeElement, 
  // (depthOfCalledByTests == 1) means that the method is directly called by tests
  // (depthOfCalledByTests == 2) means that the method is directly called by a method directly called by tests
  // …
  depthOfCalledByTests = pair.Value,
  nbLinesOfCode = pair.CodeElement.NbLinesOfCode,
  // --- Uncomment this line if your project import some coverage data ---
  // m.PercentageCoverage
}

//<Description>
// This query lists all methods *directly or indirectly* called by tests methods.
// *Indirectly* called by a test means that a test method calls a method, that calls a method…
// From this recursion, a code metric named *depthOfCalledByTests* is inferred,
// The value *1* means directly called by test,
// the value *2* means called by a method that is called by a test…
//
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used files </Name>
(from f in Application.Files orderby f.FilesUsingMe.Count() descending
 select new { f, f.FilesUsingMe }).Take(50)

]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.cppdepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level Projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify Projects by their Level values.
// See the definition of the projectLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is not using the project P2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("P2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"P1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is only using the Projects P2 or P3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("P2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("P3".AllowNoMatch().MatchProject()) ||
    a.ProjectsUsed.Count() != 2) // Must not be used more than 2 Projects 
&& 
  (a.Name == @"P1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 Projects are using Project P</Name>
warnif count != 3 from a in Application.Projects where 
  a.IsUsing ("P".AllowNoMatch().MatchProject())
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
      </Group>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Issues" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# New Issues since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasAdded()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Fixed since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasFixed()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Worsened since Baseline" Unit="issues"/>
from issue in Issues 
where !issue.WasAdded() && 
      (issue.DebtDiff() > Debt.Zero || issue.AnnualInterestDiff() > AnnualInterest.Zero)
select new { 
   issue, 
   issue.Debt, debtDiff = issue.DebtDiff(), 
   issue.AnnualInterest, annualInterestDiff = issue.AnnualInterestDiff(),
   issue.Severity 
}

//<Description>
// An issue is considered worsened if its *debt* increased since the baseline.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Blocker" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Blocker
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Critical" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Critical
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity High" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.High
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **High** should be fixed quickly, but can wait until the next scheduled interval.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Medium" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Medium
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Medium** is a warning that if not fixed, won't have a significant impact on development.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Low" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Low
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The severity level **Low** is used by issues that have a zero, or close to zero, 
// value for **Annual Interest**.
//
// Issues with a **Low** or **Medium** severity level represents small improvements, 
// ways to make the code looks more elegant.
//
// The **Broken Window Theory** https://en.wikipedia.org/wiki/Broken_windows_theory states that:
//
// *"Consider a building with a few broken windows. 
// If the windows are not repaired, the tendency is for vandals to break a few more windows. 
// Eventually, they may even break into the building, and if it's unoccupied, perhaps become 
// squatters or light fires inside."*
//

// Issues with a *Low* or *Medium* severity level represents the *broken windows* of a code base.
// If they are not fixed, the tendency is for developers to not care for living 
// in an elegant code, which will result in extra-maintenance-cost in the long term.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Blocker/Critical/High Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High)
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues with a severity Blocker, Critical or High.
//
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// An issue with a severity level **High** should be fixed quickly, but can wait until the next scheduled interval.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues" Unit="issues"/>
from issue in Issues 
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues no matter the issue severity.
//</Description>]]></Query>
      </Group>
      <Group Name="Rules" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules" Unit="rules"/>
from rule in Rules
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of active rules.
// This count includes violated and not violated rules.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated()
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of active rules that are violated.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Critical Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated() && rule.IsCritical
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of critical active rules that are violated.
//
// The concept of critical rule is useful to pinpoint certain rules that should not be violated.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Quality Gates" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates" Unit="quality gates"/>
from qualityGate in QualityGates
select new { 
   qualityGate , 
   qualityGate.ValueString,
   qualityGate.Status, 
}

//<Description>
// This trend metric counts the number of active quality gates,
// no matter the gate status (Pass, Warn, Fail).
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Warn" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Warn
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that warns.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Fail" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Fail
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that fails.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Debt" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Debt (Metric)" Unit="%" />
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Infer a percentage from:
//
// • the estimated total time to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt).
//
// Estimated total time to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-day to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Debt (Metric)" Unit="man-days" />
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Debt since Baseline (Metric)" Unit="man-days" />
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Debt added (or fixed if negative) since baseline.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Annual Interest (Metric)" Unit="man-days" />
Issues.Sum(i => i.AnnualInterest).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Annual Interest documentation: https://www.ndepend.com/docs/technical-debt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Annual Interest since Baseline (Metric)" Unit="man-days" />
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Annual Interest added (or fixed if negative) since baseline.
//
// Annual Interest documentation: https://www.ndepend.com/docs/technical-debt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point" Unit="years"/>
(Issues.Sum(i =>i.Debt).BreakingPoint(Issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: https://www.ndepend.com/docs/technical-debt#BreakingPoint
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point of Blocker / Critical / High Issues" Unit="years"/>
let issues = Issues.Where(i => i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High))
select (issues.Sum(i =>i.Debt).BreakingPoint(issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: https://www.ndepend.com/docs/technical-debt#BreakingPoint
// </Description>]]></Query>
      </Group>
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />  
Application.Projects.Sum(a => a.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Where(m => !JustMyCode.Contains(m))
                   .Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc => loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
Application.Projects.Sum(a => a.NbLinesOfComment)

// So far comments are only extracted from C# source code.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
Application.Projects.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
Application.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && !t.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Structures" Unit="Types" />
Application.Types.Count(t => t.IsStructure)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
Application.Fields.Count(f => 
   !f.IsEnumValue && 
   !f.IsGeneratedByCompiler && 
   !f.ParentType.IsEnumeration)

]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
          .Max(m => m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nb Lines of code for Files" Unit="Paths" />
Application.Files
          .Max(f => f.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nb Lines of code for Files" Unit="Paths" />
Application.Files.Where(f => f.NbLinesOfCode> 0)
                   .Average(f => f.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
          .Max(m => m.NestingDepth)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the method with highest NestingDepth.
// Application.Methods.OrderByDescending(m => m.NestingDepth).Take(1).Select(m => new {m, m.NestingDepth})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Average(m => m.NestingDepth)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
ThirdParty.Projects.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
ThirdParty.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
ThirdParty.Methods.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
ThirdParty.Fields.Count()]]></Query>
      </Group>
      <Group Name="Code Coverage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Code Coverage" Unit="%" />
((float)Application.Projects.Sum(a => a.NbLinesOfCodeCovered) /
        Application.Projects.Sum(a => a.NbLinesOfCode)
 * 100f)
.ToEnumerable().Sum()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeNotCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" />
Application.Types.Where(t => t.PercentageCoverage == 100)
           .Sum(t => t.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" />
Application.Methods.Where(m => m.PercentageCoverage == 100)
           .Sum(m => m.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Max(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Average(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
      </Group>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods with a pattern name</Name>
notmycode from m in Methods where m.SimpleName.StartsWith("pattern to exclude")
select m

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large methods that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Methods where m.NbLinesOfCode > 30 select m
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches methods defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from m in Methods where
//  m.SourceFileDeclAvailable && 
//  m.SourceDecl.SourceFile.FileName.ToLower().EndsWith(".designer.cs")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types with a pattern name</Name>
notmycode from t in Types where t.Name.StartsWith("pattern to exclude")
select t

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large types that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Types where t.NbLinesOfCode > 3000 select t
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches types defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from t in Types where
//  t.SourceFileDeclAvailable && 
//  t.SourceDecl.SourceFile.FileName.ToLower().EndsWith("pattern to exclude")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>


]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>JustMyCode code elements</Name>
from elem in JustMyCode.CodeElements
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// only shows these code elements. This code base view is used by 
// many default code rule to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones that are not matched 
// by any quere prefixed with  **notmycode**.
//</Description>]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NotMyCode code elements</Name>
from elem in Application.CodeElements.Where(element => !JustMyCode.Contains(element))
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as not being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// hide these code elements. This code base view is used by 
// many default code rules to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones matched by queries prefixed with 
// **notmycode**.
//</Description>]]></Query>
    </Group>
  </Queries>
  <WarnFilter />
</NDepend>